class Solution {
    /*
    * Greedy
    * 让二进制数尽可能的大: 高位为1的二进制数比低位为1的数大。 这里贪心，让从左侧开始，尽可能有更多的1
    * 根据题意，每行或每列都可以变化，利用上面的观点，从左侧开始 让每列有尽可能多的1
    * 如何统计当前列要不要toggle(也就是看1多还是0多): 这里用异或(^)操作，相同为0，不同为1。让当前列的所有值都和第一个元素做异或且累加，这样统计出来得到N，然后在比较 N 和 列数-N，这两个数值一个代表0，一个代表1(在这里并不需要知道谁代表0，谁代表1，只要知道那个大就足够了，因为0和1是可以互换的)
    * 然后可以开始累加(利用二进制原理开始累加 0b1000 = 2^3，0b0100 = 2^2 二进制中当1向左移动一位时，就是乘2，反之就是除2)
    */
    public int matrixScore(int[][] A) {
        int R = A.length, C = A[0].length;
        int res = 0;
        
        for (int c = 0; c < C; ++c ) {
            int curCol = 0;
            for( int r = 0; r < R; ++r ) 
                curCol += A[r][c] ^ A[r][0];
            
            // c 是从0开始计数的，所以c=0时，C-1-c就代表最左侧第一列，以此类推
            res += Math.max( curCol, R - curCol ) * ( 1 << ( C - 1 - c ) );
        }
        return res;
    }
}